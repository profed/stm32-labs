### Лабораторная 1 "Мигание светодиодом"

В данной лабораторной мы рассмотрим основные принципы подключения внешней, а также познакомимся с понятим дребезга

## Подключение светодиода

Рассмотрим функцию SetDiode из lib/device-drivers/diode.h.

```C
PortX_EnableClock(port);

LL_GPIO_SetPinMode(port, pin, LL_GPIO_MODE_OUTPUT);
```

Первый шаг при подключении какой-либо периферии - подать на нее тактирование. Без этого будет невозможно адекватно посылать и принимать сигналы. За это отвечает функция PortX_EnableClock. Посмотрим, что она делает:

```C
// lib/config/config.h
// там же находятся все переопределения пинов

int PortX_EnableClock(GPIO_TypeDef* port) {
  if (port == GPIOA) {
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
  } else if (port == GPIOB) {
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);
  } else if (port == GPIOC) {
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
  } else if (port == GPIOD) {
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);
  } else if (port == GPIOF) {
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOF);
  } else {
    return -1;
  }

  return 0;
}
```

Данная функция предназначена для параметрического подключения диода и прочей периферии в данной реализации. Она включает тактирование на нужном порте при помощи функции LL_AHB1_GRP1_EnableClock(...). Данная функция (КАКАЯ?) может без каких-либо последствий вызываться несколько раз для одного и того же параметра, т.к. все что она делает - это побитовое ИЛИ на нужном регистре.

После включения тактирования на нужном порте нужно выставить заданный пин в режим цифрового выхода, чтобы иметь возможность подать на него какое-либо значение. За это ответственна стандартная функция LL_GPIO_SetPinMode(...).

Теперь, в функции main() мы можем всячески манипулировать с этим пином, например функциями:

```C
LL_GPIO_SetOutputPin(port, pin);   // выставить порт в значение "1" - подать питание
LL_GPIO_ResetOutputPin(port, pin)  // выставить порт в значение "0" - снять питание
LL_GPIO_ToggleOutputPin(port, pin) // XOR от значения на порте

```

Попробуйте, поэкспериментируйте.

## Кнопка

Однако просто мигать диодом неинтересно. Давайте подключим кнопку и попытаемся настроить ее так, чтобы светодиод реагировал на ее нажатие. Рассмотрим подключение кнопки на примере функции SetButton из lib/device-drivers/button.h:

```C
int SetButton(GPIO_TypeDef* port, unsigned int pin) {
  PortX_EnableClock(port);

  LL_GPIO_SetPinMode(port, pin, LL_GPIO_MODE_INPUT);

  LL_GPIO_SetPinPull(port, pin, LL_GPIO_PULL_DOWN);

  return 0;
}
```

Как и в прошлый раз, работа с перифрией начинается с того, что мы включаем тактирование на нужном порте. Далее выставляем режим нужного пина на цифровой вход функцией LL_GPIO_SetPinMode(...). После этого нам необходимо установить подтяжку пина. Выставляем подтяжку пина вниз (на землю) функцией LL_GPIO_SetPinPull(...), чтобы при отсутствии сигнала с кнопки, пин был заземлен (во избежание ложного срабатывания).

После этого мы можем принимать сигнал с кнопки посредством функции LL_GPIO_IsInputPinSet(...):

```C
while (1) {
  int is_button_pressed = LL_GPIO_IsInputPinSet(GPIOA, PIN_2);

  if (is_button_pressed) {
    LL_GPIO_TogglePin(GPIOB, PIN_3);
  }
}
```

В main.c показан пример работы с LL_GPIO_IsInputPinSet: в бесконечном цикле мы каждый раз сначала опрашиваем состояние пина, потом дейтвуем в зависимости от полученного результата. В этом примере, мы включаем / выключаем диод при нажатии. Однако если собрать эту программу и проверить ее на плате, то выяснится, что она работает не совсем так, как задумывалось. А именно: при нажатии на кнопку диод ведет себя неопределенным образом. Происходит это из-за того, что при нажатии существует дребезг, т.е. вместо одного срабатывания их регистрируется порядка 20 (а то и больше). Рассмотрим как этого можно избежать. 
Можно при каждом срабатывании кнопки инкрементировать некий счетчик и, при достижении им некоторого критического значения, указывать, что кнопка действительно сработала. Ниже предоставлен примерный вариант реализации:

```C

int counter_cur = 0;  // счетчик текущего значения нажатия кнопки
int counter_max = 15; // счетчик максимального значения нажатия кнопки
int delta = 5;        // некоторое значение, внитри которого допускаются флуктуации

int main() {
    if (LL_GPIO_IsInputPinSet(port, pin))
        if (counter_cur < counter_max)
            counter_cur++;
    else
        counter_cur--;

    if (counter_cur > counter_max - delta) {
        // handle pressed button
    } else if (counter_cur < delta) {
        // handle button unpress
    }

    return 0;
}
```

Более развернутая и пригодная для применения имплементация этого алгоритма представлена в lib/device-drivers/button.h, функция Button_UpdateState(...), с использования схожего алгоритма.

## main.c

В файле main.c представлены возможные варианты работы с данной периферией, а также более подробно расписано все вышесказанное.

## Самостоятельные задания

Переделайте функцию Button_UpdateButton (а случше напишите свою), чтобы с ее помощью можно было обрабатывать нажатие с нескольких кнопок. Для проверки напишите программу, при сборке которой происходит следующее: при нажатии одной из двух кнопок происходит переключение состояния первого диода, а при нажатии второй кнопки - второго диода. Посмотрите, как вам придется переделать ваш код,  для  3, 4 и более кнопок. Удобно ли в вашей реализации добавлять обработку новой периферии? Если нет, то подумайте, как можно сделать по-другому.
